name: Slack PR Notification

on:
  pull_request_target:
    branches: ['**']  # Match all branches - scalable for any branch
    types: [opened, closed, reopened, synchronize]

env:
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

jobs:
  notify-slack:
    name: Send Slack Notification
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    steps:
      # SECURITY: Only checkout base branch, never PR code from fork
      - name: Checkout base branch (SECURITY)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          fetch-depth: 0

      - name: Get changed files via GitHub API (SECURITY)
        id: detect-changes
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            
            // Get changed files using GitHub API (safe - only reading metadata)
            let changedFiles = [];
            try {
              const files = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100
              });
              
              changedFiles = files.data.map(file => file.filename);
              
              // Calculate file statistics
              const filesAdded = files.data.filter(f => f.status === 'added').length;
              const filesRemoved = files.data.filter(f => f.status === 'removed').length;
              const filesModified = files.data.filter(f => f.status === 'modified').length;
              const filesRenamed = files.data.filter(f => f.status === 'renamed').length;
              
              // Get file type breakdown (top 5)
              const fileTypes = {};
              changedFiles.forEach(file => {
                const ext = file.split('.').pop() || 'no-ext';
                fileTypes[ext] = (fileTypes[ext] || 0) + 1;
              });
              const topTypes = Object.entries(fileTypes)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([ext, count]) => `${ext} (${count})`)
                .join(', ') || 'N/A';
              
              // Prepare file list (top 8 for Slack)
              const topFiles = changedFiles.slice(0, 8).map(f => `  ‚Ä¢ ${f}`).join('\n');
              const remainingFiles = changedFiles.length - 8;
              const fileList = changedFiles.length > 0 
                ? (remainingFiles > 0 ? `${topFiles}\n  ... and ${remainingFiles} more file(s)` : topFiles)
                : '  (No files changed)';
              
              // Set outputs
              core.setOutput('files_added', filesAdded.toString());
              core.setOutput('files_removed', filesRemoved.toString());
              core.setOutput('files_modified', filesModified.toString());
              core.setOutput('files_renamed', filesRenamed.toString());
              core.setOutput('total_files', changedFiles.length.toString());
              core.setOutput('file_types', topTypes);
              core.setOutput('file_list', fileList);
              
            } catch (error) {
              core.warning(`Failed to get changed files: ${error.message}`);
              // Set defaults on error
              core.setOutput('files_added', '0');
              core.setOutput('files_removed', '0');
              core.setOutput('files_modified', '0');
              core.setOutput('files_renamed', '0');
              core.setOutput('total_files', '0');
              core.setOutput('file_types', 'N/A');
              core.setOutput('file_list', '  (Unable to detect files)');
            }

      - name: Load file list
        id: load-files
        run: |
          {
            echo "FILE_LIST<<EOF"
            echo "${{ steps.detect-changes.outputs.file_list }}"
            echo "EOF"
          } >> $GITHUB_ENV
          
          echo "FILES_ADDED=${{ steps.detect-changes.outputs.files_added }}" >> $GITHUB_ENV
          echo "FILES_REMOVED=${{ steps.detect-changes.outputs.files_removed }}" >> $GITHUB_ENV
          echo "FILES_MODIFIED=${{ steps.detect-changes.outputs.files_modified }}" >> $GITHUB_ENV
          echo "FILES_RENAMED=${{ steps.detect-changes.outputs.files_renamed }}" >> $GITHUB_ENV
          echo "TOTAL_FILES=${{ steps.detect-changes.outputs.total_files }}" >> $GITHUB_ENV
          echo "FILE_TYPES=${{ steps.detect-changes.outputs.file_types }}" >> $GITHUB_ENV

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        run: |
          # Prepare PR information
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_URL="${{ github.event.pull_request.html_url }}"
          PR_AUTHOR="${{ github.event.pull_request.user.login }}"
          PR_AUTHOR_AVATAR="${{ github.event.pull_request.user.avatar_url }}"
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
          HEAD_REPO="${{ github.event.pull_request.head.repo.full_name }}"
          BASE_REPO="${{ github.event.pull_request.base.repo.full_name }}"
          ADDITIONS="${{ github.event.pull_request.additions }}"
          DELETIONS="${{ github.event.pull_request.deletions }}"
          CHANGED_FILES="${{ github.event.pull_request.changed_files }}"
          COMMITS="${{ github.event.pull_request.commits }}"
          
          # Detect if PR is from a fork
          IS_FORK="false"
          if [ "$HEAD_REPO" != "$BASE_REPO" ]; then
            IS_FORK="true"
            BRANCH_DISPLAY="üîÄ FORK \`$HEAD_BRANCH\` ‚Üí \`$BASE_BRANCH\`"
          else
            BRANCH_DISPLAY="\`$HEAD_BRANCH\` ‚Üí \`$BASE_BRANCH\`"
          fi
          
          # Set defaults for optional fields
          PR_AUTHOR_AVATAR="${PR_AUTHOR_AVATAR:-https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png}"
          COMMITS="${COMMITS:-0}"
          
          # Determine event type and color
          EVENT_TYPE="${{ github.event.action }}"
          MERGED="${{ github.event.pull_request.merged }}"
          MERGED_BY="${{ github.event.pull_request.merged_by.login }}"
          
          if [ "$EVENT_TYPE" = "opened" ]; then
            COLOR="#3498db"  # Blue
            TITLE="üÜï New Pull Request Opened"
            DESCRIPTION="$PR_AUTHOR created a new pull request"
          elif [ "$EVENT_TYPE" = "reopened" ]; then
            COLOR="#9b59b6"  # Purple
            TITLE="üîÑ Pull Request Reopened"
            DESCRIPTION="$PR_AUTHOR reopened this pull request"
          elif [ "$EVENT_TYPE" = "closed" ] && [ "$MERGED" = "true" ]; then
            COLOR="#2ecc71"  # Green
            TITLE="‚úÖ Pull Request Merged"
            DESCRIPTION="${MERGED_BY:-$PR_AUTHOR} merged this pull request"
          elif [ "$EVENT_TYPE" = "closed" ] && [ "$MERGED" = "false" ]; then
            COLOR="#e74c3c"  # Red
            TITLE="‚ùå Pull Request Closed"
            DESCRIPTION="$PR_AUTHOR closed this pull request without merging"
          elif [ "$EVENT_TYPE" = "synchronize" ]; then
            COLOR="#f39c12"  # Yellow
            TITLE="üìù Pull Request Updated"
            DESCRIPTION="$PR_AUTHOR pushed new commits"
          else
            COLOR="#95a5a6"  # Gray
            TITLE="üìã Pull Request Event"
            DESCRIPTION="Pull request event: $EVENT_TYPE"
          fi
          
          # Get timestamp
          TIMESTAMP=$(date +%s)
          
          # Escape special characters for JSON
          PR_TITLE_ESCAPED=$(echo "$PR_TITLE" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          DESCRIPTION_ESCAPED=$(echo "$DESCRIPTION" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          
          # Escape file list for Slack
          FILE_LIST_ESCAPED=$(echo -e "$FILE_LIST" | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          
          # Build Slack webhook payload
          cat > slack_payload.json <<EOF
          {
            "username": "GitHub CI/CD",
            "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
            "attachments": [
              {
                "color": "$COLOR",
                "title": "$TITLE",
                "title_link": "$PR_URL",
                "text": "$DESCRIPTION_ESCAPED",
                "fields": [
                  {
                    "title": "üìã Pull Request",
                    "value": "<$PR_URL|#$PR_NUMBER - $PR_TITLE_ESCAPED>",
                    "short": false
                  },
                  {
                    "title": "üë§ Author",
                    "value": "<https://github.com/$PR_AUTHOR|$PR_AUTHOR>",
                    "short": true
                  },
                  {
                    "title": "üåø Branch",
                    "value": "$BRANCH_DISPLAY",
                    "short": true
                  },
                  {
                    "title": "üìä Changes",
                    "value": "*$CHANGED_FILES* files ‚Ä¢ *$COMMITS* commits\n‚úÖ *+$ADDITIONS* lines ‚Ä¢ ‚ùå *-$DELETIONS* lines\n\nüìÅ *Files:* +$FILES_ADDED added, -$FILES_REMOVED removed, ~$FILES_MODIFIED modified\nüì¶ *Types:* $FILE_TYPES",
                    "short": false
                  },
                  {
                    "title": "üìù Changed Files ($TOTAL_FILES)",
                    "value": "$FILE_LIST_ESCAPED",
                    "short": false
                  }
                ],
                "thumb_url": "$PR_AUTHOR_AVATAR",
                "footer": "GitHub Actions ‚Ä¢ PR Notification",
                "footer_icon": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
                "ts": $TIMESTAMP
              }
            ]
          }
          EOF
          
          # Send to Slack
          echo "Sending notification to Slack..."
          
          RESPONSE=$(curl -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d @slack_payload.json \
            -w "\n%{http_code}" \
            -s)
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Successfully sent Slack notification (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è Slack webhook returned HTTP $HTTP_CODE"
            echo "Response: $RESPONSE"
            # Don't fail the workflow if Slack notification fails
          fi
